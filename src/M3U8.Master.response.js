/*
README: https://github.com/DualSubs
*/

import ENVs from "./ENV/ENV.mjs";
import URIs from "./URI/URI.mjs";
import EXTM3U from "./EXTM3U/EXTM3U.mjs";

import setENV from "./function/setENV.mjs";
import detectPlatform from "./function/detectPlatform.mjs";
import detectFormat from "./function/detectFormat.mjs";

import * as Database from "./database/Database.json";

const $ = new ENVs("üçøÔ∏è DualSubs: üé¶ Universal v0.9.6(2) M3U8.Master.response");
const URI = new URIs();
const M3U8 = new EXTM3U(["\n"]);

/***************** Processing *****************/
// Ëß£ÊûÑURL
const URL = URI.parse($request.url);
$.log(`‚ö† ${$.name}`, `URL: ${JSON.stringify(URL)}`, "");
// Ëé∑ÂèñËøûÊé•ÂèÇÊï∞
const METHOD = $request.method, HOST = URL.host, PATH = URL.path, PATHs = URL.paths;
$.log(`‚ö† ${$.name}`, `METHOD: ${METHOD}`, "");
// Ëé∑ÂèñÂπ≥Âè∞
const PLATFORM = detectPlatform(HOST);
$.log(`‚ö† ${$.name}, PLATFORM: ${PLATFORM}`, "");
// Ëß£ÊûêÊ†ºÂºè
let FORMAT = ($response.headers?.["Content-Type"] ?? $response.headers?.["content-type"])?.split(";")?.[0];
if (FORMAT === "application/octet-stream" || FORMAT === "text/plain") FORMAT = detectFormat(URL, $response?.body);
$.log(`‚ö† ${$.name}, FORMAT: ${FORMAT}`, "");
(async () => {
	// ËØªÂèñËÆæÁΩÆ
	const { Settings, Caches, Configs } = setENV("DualSubs", [(["YouTube", "Netflix", "BiliBili", "Spotify"].includes(PLATFORM)) ? PLATFORM : "Universal"], Database);
	$.log(`‚ö† ${$.name}`, `Settings.Switch: ${Settings?.Switch}`, "");
	switch (Settings.Switch) {
		case true:
		default:
			// Ëé∑ÂèñÂ≠óÂπïÁ±ªÂûã‰∏éËØ≠Ë®Ä
			const Type = URL.query?.subtype ?? Settings.Type, Languages = [URL.query?.lang?.toUpperCase?.() ?? Settings.Languages[0], (URL.query?.tlang ?? Caches?.tlang)?.toUpperCase?.() ?? Settings.Languages[1]];
			$.log(`‚ö† ${$.name}, Type: ${Type}, Languages: ${Languages}`, "");
			// ÂÖºÂÆπÊÄßÂà§Êñ≠
			const { standard: STANDARD, device: DEVICE } = isStandard(URL, $request.headers, PLATFORM);
			// ÂàõÂª∫Á©∫Êï∞ÊçÆ
			let body = {};
			// Ê†ºÂºèÂà§Êñ≠
			switch (FORMAT) {
				case undefined: // ËßÜ‰∏∫Êó†body
					break;
				case "application/x-www-form-urlencoded":
				case "text/plain":
				case "text/html":
				default:
					break;
				case "application/x-mpegURL":
				case "application/x-mpegurl":
				case "application/vnd.apple.mpegurl":
				case "audio/mpegurl":
					// Â∫èÂàóÂåñM3U8
					body = M3U8.parse($response.body);
					//$.log(`üöß ${$.name}`, "M3U8.parse($response.body)", JSON.stringify(body), "");
					// ËØªÂèñÂ∑≤Â≠òÊï∞ÊçÆ
					let playlistCache = Caches.Playlists.Master.get($request.url) || {};
					// Ëé∑ÂèñÁâπÂÆöËØ≠Ë®ÄÁöÑÂ≠óÂπï
					playlistCache[Languages[0]] = getAttrList($request.url, body, "SUBTITLES", Configs.Languages[Languages[0]]);
					playlistCache[Languages[1]] = getAttrList($request.url, body, "SUBTITLES", Configs.Languages[Languages[1]]);
					// ÂÜôÂÖ•Êï∞ÊçÆ
					Caches.Playlists.Master.set($request.url, playlistCache);
					// Ê†ºÂºèÂåñÁºìÂ≠ò
					Caches.Playlists.Master = setCache(Caches.Playlists.Master, Settings.CacheSize);
					// ÂÜôÂÖ•ÊåÅ‰πÖÂåñÂÇ®Â≠ò
					$.setjson(Caches.Playlists.Master, `@DualSubs.${"Composite"}.Caches.Playlists.Master`);
					// ÂÜôÂÖ•ÈÄâÈ°π
					body = setAttrList(body, playlistCache, Settings.Types, Languages, PLATFORM, STANDARD, DEVICE);
					// Â≠óÁ¨¶‰∏≤M3U8
					$response.body = M3U8.stringify(body);
					break;
			};
			break;
		case false:
			break;
	};
})()
	.catch((e) => $.logErr(e))
	.finally(() => {
		switch ($response) {
			default: { // ÊúâÂõûÂ§çÊï∞ÊçÆÔºåËøîÂõûÂõûÂ§çÊï∞ÊçÆ
				$.log(`üéâ ${$.name}, finally`, `$response`, `FORMAT: ${FORMAT}`, "");
				//$.log(`üöß ${$.name}, finally`, `$response: ${JSON.stringify($response)}`, "");
				if ($response?.headers?.["Content-Encoding"]) $response.headers["Content-Encoding"] = "identity";
				if ($response?.headers?.["content-encoding"]) $response.headers["content-encoding"] = "identity";
				if ($.isQuanX()) {
					switch (FORMAT) {
						case undefined: // ËßÜ‰∏∫Êó†body
							// ËøîÂõûÊôÆÈÄöÊï∞ÊçÆ
							$.done({ status: $response.status, headers: $response.headers });
							break;
						default:
							// ËøîÂõûÊôÆÈÄöÊï∞ÊçÆ
							$.done({ status: $response.status, headers: $response.headers, body: $response.body });
							break;
						case "application/protobuf":
						case "application/x-protobuf":
						case "application/vnd.google.protobuf":
						case "application/grpc":
						case "application/grpc+proto":
						case "applecation/octet-stream":
							// ËøîÂõû‰∫åËøõÂà∂Êï∞ÊçÆ
							//$.log(`${$response.bodyBytes.byteLength}---${$response.bodyBytes.buffer.byteLength}`);
							$.done({ status: $response.status, headers: $response.headers, bodyBytes: $response.bodyBytes.buffer.slice($response.bodyBytes.byteOffset, $response.bodyBytes.byteLength + $response.bodyBytes.byteOffset) });
							break;
					};
				} else $.done($response);
				break;
			};
			case undefined: { // Êó†ÂõûÂ§çÊï∞ÊçÆ
				break;
			};
		};
	})

/***************** Function *****************/
/**
 * Set Cache
 * @author VirgilClyne
 * @param {Map} cache - Playlists Cache / Subtitles Cache
 * @param {Number} cacheSize - Cache Size
 * @return {Boolean} isSaved
 */
function setCache(cache, cacheSize = 100) {
	$.log(`‚òëÔ∏è ${$.name}, Set Cache, cacheSize: ${cacheSize}`, "");
	cache = Array.from(cache || []); // MapËΩ¨Array
	cache = cache.slice(-cacheSize); // ÈôêÂà∂ÁºìÂ≠òÂ§ßÂ∞è
	$.log(`‚úÖ ${$.name}, Set Cache`, "");
	return cache;
};

/**
 * Get Attribute List
 * @author VirgilClyne
 * @param {String} url - Request URL
 * @param {Object} m3u8 - Parsed M3U8
 * @param {String} type - Content Type
 * @param {Array} langCodes - Language Codes Array
 * @return {Array} datas
 */
function getAttrList(url = "", m3u8 = {}, type = "", langCodes = []) {
	$.log(`‚òëÔ∏è $${$.name}, Get Attribute List`, `langCodes: ${langCodes}`, "");
	let attrList = m3u8.filter(item => item?.OPTION?.TYPE === type && item?.OPTION?.FORCED !== "YES"); // ËøáÊª§Âº∫Âà∂ÂÜÖÂÆπ
	//$.log(`üöß ${$.name}`, "attrList", JSON.stringify(attrList), "");
	let matchList = [];
	//Êü•ËØ¢ÊòØÂê¶ÊúâÁ¨¶ÂêàËØ≠Ë®ÄÁöÑÂÜÖÂÆπ
	for (let langcode of langCodes) {
		$.log(`üöß ${$.name}, Get Attribute List`, "for (let langcode of langcodes)", `langcode: ${langcode}`, "");
		matchList = attrList.filter(item => item?.OPTION?.LANGUAGE?.toLowerCase() === langcode?.toLowerCase());
		if (matchList.length !== 0) break;
	};
	matchList = matchList.map(data => {
		data.URL = aPath(url, data?.OPTION?.URI ?? null);
		return data;
	})
	$.log(`‚úÖ $${$.name}, Get Attribute List`, `matchList: ${JSON.stringify(matchList)}`, "");
	return matchList;

	/***************** Fuctions *****************/
	// Get Absolute Path
	function aPath(aURL = "", URL = "") { return (/^https?:\/\//i.test(URL)) ? URL : aURL.match(/^(https?:\/\/(?:[^?]+)\/)/i)?.[0] + URL };
};

/**
 * Set Attribute List
 * @author VirgilClyne
 * @param {String} platform - Platform
 * @param {Object} m3u8 - Parsed m3u8
 * @param {Array} playlists1 - Primary (Source) Languages Playlists
 * @param {Array} playlists2 - Second (Target) Languages Playlists
 * @param {Array} types - Types
 * @param {Array} languages - Languages
 * @param {Boolean} Standard - Standard
 * @return {Object} m3u8
 */
function setAttrList(m3u8 = {}, playlists = {}, types = [], languages = [], platform = "", standard = true, device = "iPhone") {
	types = (standard == true) ? types : [types.at(-1)];
	const playlists1 = playlists?.[languages?.[0]];
	const playlists2 = playlists?.[languages?.[1]];
	$.log(`‚òëÔ∏è ${$.name}, Set Attribute List`, `types: ${types}`, "");
	playlists1?.forEach(playlist1 => {
		const index1 = m3u8.findIndex(item => item?.OPTION?.URI === playlist1.OPTION.URI); // ‰∏ªËØ≠Ë®ÄÔºàÊ∫êËØ≠Ë®ÄÔºâÂ≠óÂπï‰ΩçÁΩÆ
		types.forEach(type => {
			$.log(`üöß ${$.name}, Set Attribute List, type: ${type}`, "");
			let option = {};
			switch (type) {
				case "Official":
					playlists2?.forEach(playlist2 => {
						if (playlist1?.OPTION?.["GROUP-ID"] === playlist2?.OPTION?.["GROUP-ID"]) {
							switch (platform) { // ÂÖºÂÆπÊÄß‰øÆÊ≠£
								case "Apple":
									if (playlist1?.OPTION.CHARACTERISTICS == playlist2?.OPTION.CHARACTERISTICS) {  // Âè™ÁîüÊàêÂ±ûÊÄßÁõ∏Âêå
										option = setOption(playlist1, playlist2, type, platform, standard, device);
									};
									break;
								default:
									option = setOption(playlist1, playlist2, type, platform, standard, device);
									break;
							};
						};
					});
					break;
				case "Translate":
				case "External":
					const playlist2 = {
						"OPTION": {
							"TYPE": "SUBTITLES",
							"NAME": playlists2?.[0]?.OPTION?.NAME ?? languages[1].toLowerCase(),
							"LANGUAGE": playlists2?.[0]?.OPTION?.LANGUAGE ?? languages[1].toLowerCase(),
						}
					};
					option = setOption(playlist1, playlist2, type, platform, standard, device);
					option.OPTION.URI += `&lang=${playlist1?.OPTION?.LANGUAGE?.toUpperCase()}`;
					break;
			};
			if (Object.keys(option).length !== 0) {
				if (standard) m3u8.splice(index1 + 1, 0, option)
				else m3u8.splice(index1, 1, option);
			};
		});
	});
	//$.log(`‚úÖ ${$.name}, Set Attribute List`, `m3u8: ${JSON.stringify(m3u8)}`, "");
	$.log(`‚úÖ ${$.name}, Set Attribute List`, "");
	return m3u8;
};

/**
 * Set DualSubs Subtitle Options
 * @author VirgilClyne
 * @param {String} platform - platform
 * @param {Array} playlist1 - Subtitles Playlist (Languages 0)
 * @param {Array} playlist2 - Subtitles Playlist (Languages 1)
 * @param {Array} enabledTypes - Enabled Types
 * @param {Array} translateTypes - Translate Types
 * @param {String} Standard - Standard
 * @return {Promise<*>}
 */
function setOption(playlist1 = {}, playlist2 = {}, type = "", platform = "", standard = true, device = "iPhone") {
	$.log(`‚òëÔ∏è ${$.name}, Set DualSubs Subtitle Option, type: ${type}, standard: ${standard}, device: ${device}`, "");
	const NAME1 = playlist1?.OPTION?.NAME.trim(), NAME2 = playlist2?.OPTION?.NAME.trim();
	const LANGUAGE1 = playlist1?.OPTION?.LANGUAGE.trim(), LANGUAGE2 = playlist2?.OPTION?.LANGUAGE.trim();
	// Â§çÂà∂Ê≠§ËØ≠Ë®ÄÈÄâÈ°π
	let newOption = JSON.parse(JSON.stringify(playlist1));
	// ‰øÆÊîπÂêçÁß∞
	switch (type) {
		case "Official":
			newOption.OPTION.NAME = `ÂÆòÊñπÂ≠óÂπï (${NAME1}/${NAME2})`;
			break;
		case "Translate":
			newOption.OPTION.NAME = `ÁøªËØëÂ≠óÂπï (${NAME1}/${NAME2})`;
			break;
		case "External":
			newOption.OPTION.NAME = `Â§ñÊåÇÂ≠óÂπï (${NAME1})`;
			break;
	};
	// ‰øÆÊîπËØ≠Ë®Ä‰ª£Á†Å
	switch (platform) {
		case "Apple": // AVKit ËØ≠Ë®ÄÂàóË°®ÂêçÁß∞ÊòæÁ§∫‰∏∫LANGUAGEÂ≠óÁ¨¶‰∏≤ Ëá™Âä®Êò†Â∞ÑLANGUAGE‰∏∫Êú¨Âú∞ËØ≠Ë®ÄNAME ‰∏çÊåâLANGUAGEÂå∫ÂàÜËØ≠Ë®Ä
		case "MGM+": // AVKit ËØ≠Ë®ÄÂàóË°®ÂêçÁß∞ÊòæÁ§∫‰∏∫LANGUAGEÂ≠óÁ¨¶‰∏≤ Ëá™Âä®Êò†Â∞ÑLANGUAGE‰∏∫Êú¨Âú∞ËØ≠Ë®ÄNAME
			switch (device) {
				case "Web":
				case "Macintosh":
					newOption.OPTION.LANGUAGE = LANGUAGE1;
					break;
				default:
					newOption.OPTION.LANGUAGE = `${type} (${LANGUAGE1}/${LANGUAGE2})`;
					break;
			};
			break;
		case "Disney+": // AppleCoreMedia ËØ≠Ë®ÄÂàóË°®ÂêçÁß∞ÊòæÁ§∫‰∏∫NAMEÂ≠óÁ¨¶‰∏≤ Ëá™Âä®Êò†Â∞ÑNAME‰∏∫Êú¨Âú∞ËØ≠Ë®ÄNAME ÊåâLANGUAGEÂå∫ÂàÜËØ≠Ë®Ä
		case "PrimeVideo": // AppleCoreMedia ËØ≠Ë®ÄÂàóË°®ÂêçÁß∞ÊòæÁ§∫‰∏∫NAMEÂ≠óÁ¨¶‰∏≤ ÊåâLANGUAGEÂå∫ÂàÜËØ≠Ë®Ä
		case "Hulu": // AppleCoreMedia ËØ≠Ë®ÄÂàóË°®ÂêçÁß∞ÊòæÁ§∫‰∏∫LANGUAGEÂ≠óÁ¨¶‰∏≤ Ëá™Âä®Êò†Â∞ÑLANGUAGE‰∏∫Êú¨Âú∞ËØ≠Ë®ÄNAME Á©∫Ê†ºÂàÜÂâ≤
		case "Nebula":  // AppleCoreMedia ËØ≠Ë®ÄÂàóË°®ÂêçÁß∞ÊòæÁ§∫‰∏∫LANGUAGEÂ≠óÁ¨¶‰∏≤ Ëá™Âä®Êò†Â∞ÑLANGUAGE‰∏∫Êú¨Âú∞ËØ≠Ë®ÄNAME
			newOption.OPTION.LANGUAGE = `${type} (${LANGUAGE1}/${LANGUAGE2})`;
			break;
		case "Max": // AppleCoreMedia
		case "HBOMax": // AppleCoreMedia
		case "Viki":
			newOption.OPTION.LANGUAGE = LANGUAGE1;
			break;
		case "Paramount+":
		case "Discovery+Ph":
			newOption.OPTION.LANGUAGE = `${type} (${LANGUAGE1}/${LANGUAGE2})`;
			break;
		default:
			newOption.OPTION.LANGUAGE = LANGUAGE1;
			break;
	};
	// Â¢ûÂä†/‰øÆÊîπÁ±ªÂûãÂèÇÊï∞
	// Â¢ûÂä†ÂâØËØ≠Ë®Ä
	newOption.OPTION["ASSOC-LANGUAGE"] = LANGUAGE2;
	// ‰øÆÊîπÈìæÊé•
	const symbol = (newOption.OPTION.URI.includes("?")) ? "&" : "?";
	newOption.OPTION.URI += `${symbol}subtype=${type}`;
	// Ëá™Âä®ÈÄâÊã©
	newOption.OPTION.AUTOSELECT = "YES";
	// ÂÖºÂÆπÊÄß‰øÆÊ≠£
	if (!standard) newOption.OPTION.DEFAULT = "YES";
	$.log(`‚úÖ ${$.name}, Set DualSubs Subtitle Option`, `newOption: ${JSON.stringify(newOption)}`, "");
	return newOption;
};

/**
 * is Standard?
 * Determine whether Standard Media Player
 * @author VirgilClyne
 * @param {String} _url - Parsed Request URL
 * @param {Object} headers - Request Headers
 * @param {String} platform - Steaming Media Platform
 * @return {Promise<*>}
 */
function isStandard(_url, headers, platform) {
	$.log(`‚òëÔ∏è ${$.name}, is Standard`, "");
	const UA = (headers?.["user-agent"] ?? headers?.["User-Agent"]);
	let standard = true;
	let device = "iPhone";
	if (UA?.includes("Mozilla/5.0")) device = "Web";
	else if (UA?.includes("iPhone")) device = "iPhone";
	else if (UA?.includes("iPad")) device = "iPad";
	else if (UA?.includes("Macintosh")) device = "Macintosh";
	else if (UA?.includes("AppleTV")) device = "AppleTV";
	else if (UA?.includes("Apple TV")) device = "AppleTV";
	switch (platform) {
		case "Max":
		case "HBOMax":
		case "Viki":
			if (UA?.includes("Mozilla/5.0")) standard = false;
			else if (UA?.includes("iPhone")) standard = false;
			else if (UA?.includes("iPad")) standard = false;
			else if (UA?.includes("Macintosh")) standard = false;
			else if (headers?.["x-hbo-device-name"]?.includes("ios")) standard = false, device = "iPhone";
			else if (_url?.query?.["device-code"] === "iphone") standard = false, device = "iPhone";
			break;
		case "PeacockTV":
			if (UA?.includes("Mozilla/5.0")) standard = false;
			else if (UA?.includes("iPhone")) standard = false;
			else if (UA?.includes("iPad")) standard = false;
			else if (UA?.includes("Macintosh")) standard = false;
			else if (UA?.includes("PeacockMobile")) standard = false;
			break;
		case "FuboTV":
			if (UA?.includes("iPhone")) standard = false;
			else if (UA?.includes("iPad")) standard = false;
			else if (UA?.includes("Macintosh")) standard = false;
			break;
		case "TED":
			if (UA?.includes("Mozilla/5.0")) standard = false;
			break;
	};
	$.log(`‚úÖ ${$.name}, is Standard, standard: ${standard}, device: ${device}`, "");
	return {standard, device};
};
